\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Programmazione Avanzata}
\author{Luca Seggiani}
\date{2025}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% testo cerchiato
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=java, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 07-10-25}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Classi final}
All'opposto delle classi astratte ci sono le classi \lstinline|final|: queste sono classi che non possono essere estese.
I metodi definiti nelle classi \lstinline|final| sono necessariamente \lstinline|final|, cioè non sovrascrivibili.

In Java, le classi \lstinline|final| sono poche: principalmente si usano metodi \lstinline|final| per impedire a chi estende la classe che contiene il metodo di modificarne il comportamento.

\subsection{Interfacce}
Le \textbf{interfacce} sono un paradigma simile a quello delle classi astratte, ma solitamente più usate in Java.

Dal punto di vista sintattico si definiscono come una raccolta di metodi astratti: in pratica ci permettono di definire modelli di comportamento standard che più classi possono implementare.
Quando una classe implementa un interfaccia, chi sa interagire con quell'interfaccia sa automaticamente interagire con quella classe. 
In particolare, si possono creare \textit{riferimenti} di tipo interfaccia, ma non \textit{oggetti} di tipo interfaccia.
I riferimenti di tipo interfaccia riferiranno a un qualsiasi oggetto che implementa l'interfaccia. 

Per definire un'interfaccia si usa la parola chiave \lstinline|interface| e una sintassi simile a quella delle classi.
Automaticamente tutti i metodi definiti sono \lstinline|abstract| e \lstinline|public|.

\subsubsection{Implementare interfacce}
Per una classe, implementare l'interfaccia (attraverso la parola chiave \lstinline|implements|) significa definire \textit{tutti} i metodi dell'interfaccia, a meno che la classe sia astratta.
Una classe può implementare tutte le interfacce che vuole: solo le \lstinline|extends| sono forzatamente unarie. Si può quindi avere.
\begin{lstlisting}[language=java, style=codestyle]	
class A extends B implements C, D, ... { /* ... */ }
\end{lstlisting}

\subsection{Tipi enumerazione}
I \textbf{tipi enumerazione} sono sostanzialmente interfacce che definiscono variabili costante intere (i campi sono automaticamente \lstinline|public|, \lstinline|static| e \lstinline|final| nelle interfacce), che si possono poi usare come identificatori costanti (e semanticamente coerenti con lo scopo del tipo enumerazione).

Si può usare la parola chiave \lstinline|enum| per non dover definire esplicitamente gli interi, ad esempio:
\begin{lstlisting}[language=java, style=codestyle]	
enum Colori {
	ROSSO,
	VERDE,
	GIALLO
}
\end{lstlisting}

Abbiamo che gli \lstinline|enum| in Java sono effettivamente definiti come una classe, la classe \lstinline|Enum<E>| implementata in \lstinline|java.lang.Enum|.

Sono per questo dotati di alcune funzioni di utilità, tra cui \lstinline|toString()| e \lstinline|name()| per ottenere i nomi dei campi dell'\lstinline|enum| a tempo di esecuzione (impossibile in linguaggi come il C++, a meno di non definire macchinose conversioni esplicite in stringhe).
In particolare, la differenza fra \lstinline|toString()| e \lstinline|name()| è che \lstinline|name()| è \lstinline|final|, mentre \lstinline|toString()| è ridefinibile da ogni classe \lstinline|enum|.

\subsection{Eccezioni}
Il Java permette la gestione delle eccezioni secondo il meccanismo noto ad esempio dal C++.
In particolare, la tassonomia delle classe di eccezione è la seguente:
\begin{center}
	\begin{forest}
		[Object, rectstyle
			[Throwable
				[Error
					[LinkageError]
					[..., draw=none]
					[VirtualMachineError]
				]
				[Exception
					[RuntimeException [..., draw=none]]
					[..., draw=none]
				]
			]
		]	
	\end{forest}
\end{center}

L'oggetto Throwable può essere \textit{lanciato}, cioè mandato al chiamante attraverso la parola chiave \lstinline|throw|.
Questo definirà il classico blocco \lstinline|try { /* ... */} catch(Exception e) { /* gestore */ }| per implementare il gestore di eccezioni.

Esistono eccezioni di tipo \textbf{checked} e \textbf{unchecked}:
\begin{itemize}
	\item \textbf{Checked}: fanno parte della \textit{firma} della funzione che le lancia, e bisogna quindi che queste lo dichiarino (con la parola chiave \lstinline|throws|) e il chiamante definisca un gestore (o a sua volta dichiari di poter inoltrare l'eccezione). Sono di questo tipo tutte le classi che estendono Exception tranne RuntimeException;
	\item \textbf{Unhecked}: rappresentano errori di programmazione o comunque non rimediabili a tempo di esecuzione, e non è necessario gestirne un gestore (ci aspettiamo che sia il gestore di default a stampare informazioni ed arrestare il programma). Sono di questo tipo le specializzazioni di:
		\begin{itemize}
			\item \textbf{Error}: rappresentano errori interni alla JVM, o comunque specifici del linguaggio Java. Non ci aspettiamo che il progammatore possa gestirli, e quindi terminano il programma;
			\item \textbf{RuntimeException}: rappresentano errori di programmazione irrecuperabili come accessi fuori buond ad array, ecc...
		\end{itemize}
\end{itemize}

\subsubsection{Blocchi \lstinline|try|-\lstinline|catch|-\lstinline|finally|}
Vediamo nello specifico come si trattano le chiamate a metodi che possono lanciare eccezioni, e il modo in cui si definiscono gestori di eccezioni.
Un classico blocco \lstinline|try|-\lstinline|catch|-\lstinline|finally| in Java ha l'aspetto:
\begin{lstlisting}[language=java, style=codestyle]	
try {
	// statement
} catch(Exception1 e1) {
	// gestisci Exception1
} catch(Exception2 e2) {
	// gestisci Exception2
}
// ...
finally {
	// blocco finally 
}
\end{lstlisting}

Vediamone le componenti:
\begin{itemize}
	\item Il blocco \lstinline|try| contiene il codice che vogliamo eseguire, cioè probabilmente una chiamata a metodo che lancia Exception1 e Exception2;
	\item Il blocco \lstinline|catch| cattura una certa eccezione (specificata negli argomenti, può catturare più eccezioni se si usa il separatore \lstinline|||). A questo punto dovrà definire codice che si occupa di gestire tale eccezione;
	\item Il blocco \lstinline|finally| contiene codice che viene eseguito dopo che tutta l'elaborazione precedente, sia stata dalla \lstinline|try| o dalle \lstinline|catch|, è stata eseguita. Ha principalmente lo scopo di permetterci di fare pulizia se un'operazione su risorse (come un accesso a file) fallisce.
\end{itemize}

I blocchi \lstinline|catch| vengono valutati sequenzialmente quando viene lanciata un eccezione: è inutile definire un gestore di eccezione se in seguito se ne definisce uno per un suo sottotipo, in quanto il primo verrà sempre eseguito al posto del secondo quando possibile (e in questo caso è possibile sempre).

\subsubsection{Clausola \lstinline|throws|}
Abbiamo introdotto come la parola chiave \lstinline|throws| specifica per il \textit{contratto} della funzione che questa può lanciare una certa eccezione \textit{checked}: approfondiamo questo aspetto.
Inserire le eccezioni lanciate costringe il programmatore che usa il metodo a capire cosa potrebbe succedere, e risolvere correttamente le situazioni critiche.
Proprio per questo motivo, a dispetto del polimorfismo è opportuno che le eccezioni specificate siano il più specifiche possibile.

I blocchi di inizializzazione statici non possono lanciare eccezioni \textit{checked} in quanto non possiedono clausola \lstinline|throws|: di contro i blocchi di inizializzazione non statici prendono direttamente la clausola \lstinline|throws| del costruttore di classi (e infatti ne sono considerati parte). 

Nel caso dell'ereditarietà, abbiamo che:
\begin{itemize}
	\item Se si sovrascrive un metodo con clausola \lstinline|throws|, bisogna specificare una causola \lstinline|throws| del metoodo sovrascritto con la stessa eccezione o un suo sottotipo (a meno che il metodo sovrascritto non lanci eccezioni di qualsiasi tipo). Sostanzialmente, vogliamo assicurarci che chiunque vede soltanto il metodo base (ad esempio da un riferimento a superclasse) possa gestire l'eccezione;
	\item Se un metodo esiste in più interfacce, e ha clausole \lstinline|throws| diverse in ognuna, dovrà implementarle tutte nella classe che implementa le interfacce.
\end{itemize}

\end{document}
